{
    "description": "We often keep patients in the ICU longer than necessary because transfers to step-down or wards happen late in the day. That blocks beds for new admissions. I want to shift transfers earlier (when possible) so ICU beds free up sooner.",
    "parameters": {
        "NumberOfPatients": {
            "shape": [],
            "definition": "Total number of rows in admissions dataset",
            "type": "integer"
        },
        "NumberOfICUStays": {
            "shape": [],
            "definition": "Total number of rows in icustays dataset",
            "type": "integer"
        },
        "NumberOfTransfers": {
            "shape": [],
            "definition": "Total number of rows in transfers dataset",
            "type": "integer"
        },
        "ICULengthOfStay": {
            "shape": [
                140
            ],
            "definition": "Length of stay in ICU for each admission",
            "type": "float"
        },
        "ICUInTimes": {
            "shape": [
                140
            ],
            "definition": "In-time for each ICU stay",
            "type": "integer"
        },
        "ICUOutTimes": {
            "shape": [
                140
            ],
            "definition": "Out-time for each ICU stay",
            "type": "integer"
        },
        "TransferInTimes": {
            "shape": [
                1190
            ],
            "definition": "In-time for each transfer event",
            "type": "integer"
        },
        "TransferOutTimes": {
            "shape": [
                1190
            ],
            "definition": "Out-time for each transfer event",
            "type": "integer"
        }
    },
    "objective": {
        "description": "Minimize the total ICU bed occupancy time by shifting patient transfers to earlier times when medically feasible",
        "formulation": "$\\min \\sum_{i=1}^{140} HasTransfer_i \\cdot (TransferTimes_i - ICUInTimes_i)$",
        "code": "model.setObjective(quicksum(HasTransfer[i] * (TransferTimes[i] - ICUInTimes[i]) for i in range(140)), GRB.MINIMIZE)"
    },
    "constraints": [
        {
            "description": "Transfer time cannot be earlier than the minimum required ICU stay duration for each patient",
            "formulation": "$\\\\forall i \\\\in \\\\{1, ..., 140\\\\}, TransferTimes[i] \\\\geq ICUInTimes[i] + MinRequiredStay[i]$",
            "code": "for i in range(140):\n    model.addConstr(TransferTimes[i] >= ICUInTimes[i] + MinRequiredStay[i])"
        },
        {
            "description": "Transfers cannot be scheduled outside of operational hours when staff is available",
            "formulation": "$\\\\forall i \\\\in \\\\{1, ..., 140\\\\}, \\\\sum_{t} OperationalHours[t] \\\\cdot TimeSlotSelected[i,t] = 1 \\\\text{ and } TransferTimes[i] = \\\\sum_{t} t \\\\cdot TimeSlotSelected[i,t]$",
            "code": "# Assuming we have time slots from 0 to some max time T, and OperationalHours and TimeSlotSelected are defined\n# We need to determine the range of t - assuming it covers the planning horizon discretized into time slots\n# For this example, I'll assume time slots go from 0 to 23 (24 hours) but this should be adjusted based on actual problem setup\n\nfor i in range(140):\n    # Each patient must be transferred during exactly one operational time slot\n    model.addConstr(sum(OperationalHours[t] * TimeSlotSelected[i,t] for t in range(24)) == 1)\n    \n    # Transfer time is defined by the selected time slot\n    model.addConstr(TransferTimes[i] == sum(t * TimeSlotSelected[i,t] for t in range(24)))"
        },
        {
            "description": "auxiliary constraint",
            "formulation": "$\\\\forall i \\\\in \\\\{1, ..., 140\\\\}, \\\\sum_{t=1}^{24} TimeSlotSelected[i,t] = 1$",
            "code": "for i in range(140):\n    model.addConstr(sum(TimeSlotSelected[i, t] for t in range(24)) == 1)"
        },
        {
            "description": "auxiliary constraint",
            "formulation": "$\\\\forall i \\\\in \\\\{1, ..., 140\\\\}, \\\\forall t \\\\in \\\\{1, ..., 24\\\\}, TimeSlotSelected[i,t] \\\\leq OperationalHours[t]$",
            "code": "for i in range(140):\n    for t in range(24):\n        model.addConstr(TimeSlotSelected[i,t] <= OperationalHours[t])"
        },
        {
            "description": "Each ICU patient can have at most one transfer out of the ICU",
            "formulation": "$\\\\forall i \\\\in \\\\{1, 2, \\\\ldots, 140\\\\}, HasTransfer[i] \\\\leq 1$",
            "code": "for i in range(140):\n    model.addConstr(HasTransfer[i] <= 1)"
        },
        {
            "description": "The total number of simultaneous transfers cannot exceed available transfer resources",
            "formulation": "$\\\\forall t, \\\\sum_{i=1}^{140} TransferActive[i,t] \\\\leq MaxSimultaneousTransfers$",
            "code": "# Assuming TransferActive is a 2D variable [140, T] and MaxSimultaneousTransfers is defined\n# Also assuming T represents the number of time periods in the planning horizon\nfor t in range(T):\n    model.addConstr(sum(TransferActive[i, t] for i in range(140)) <= MaxSimultaneousTransfers)"
        },
        {
            "description": "auxiliary constraint",
            "formulation": "$\\\\forall i, t, TransferActive[i,t] \\\\geq HasTransfer[i] \\\\cdot (1 - (TransferTimes[i] - t + TransferDuration[i])/M) - (1 - HasTransfer[i])$",
            "code": "# Assuming TransferActive is defined as a binary variable with appropriate dimensions\n# Assuming TransferDuration is available as a parameter\n# Assuming M is a large constant and time horizon T is defined\nM = 1000  # Big-M constant\nT = 24    # Assuming 24 time periods (hours)\n\nfor i in range(140):\n    for t in range(T):\n        model.addConstr(TransferActive[i,t] >= HasTransfer[i] * (1 - (TransferTimes[i] - t + TransferDuration[i])/M) - (1 - HasTransfer[i]))"
        },
        {
            "description": "auxiliary constraint",
            "formulation": "$\\\\forall i, t, TransferActive[i,t] \\\\geq HasTransfer[i] \\\\cdot (1 - (t - TransferTimes[i] + 1)/M) - (1 - HasTransfer[i])$",
            "code": "M = 1000  # Big-M parameter\nmax_time = 168  # Assuming a week-long planning horizon in hours\n\nfor i in range(140):  # NumberOfICUStays is 140 based on the variable shapes\n    for t in range(max_time + 1):\n        model.addConstr(TransferActive[i, t] >= HasTransfer[i] * (1 - (t - TransferTimes[i] + 1) / M) - (1 - HasTransfer[i]))"
        },
        {
            "description": "Transfer out time must be after or equal to the ICU admission time for each patient",
            "formulation": "$\\\\forall i, \\\\text{HasTransfer}[i] = 1 \\\\Rightarrow \\\\text{TransferTimes}[i] \\\\geq \\\\text{ICUInTimes}[i]$",
            "code": "for i in range(NumberOfICUStays):\n    model.addConstr((HasTransfer[i] == 1) >> (TransferTimes[i] >= ICUInTimes[i]))"
        },
        {
            "description": "The shifted transfer time must be non-negative and within the planning horizon",
            "formulation": "$\\\\forall i \\\\in \\\\{1, ..., 140\\\\}, 0 \\\\leq TransferTimes[i] \\\\leq PlanningHorizon$",
            "code": "for i in range(140):\n    model.addConstr(TransferTimes[i] >= 0)\n    model.addConstr(TransferTimes[i] <= PlanningHorizon)"
        }
    ],
    "variables": {
        "TransferTimes": {
            "shape": [
                140
            ],
            "type": "continuous",
            "definition": "The optimized transfer time for each ICU stay"
        },
        "MinRequiredStay": {
            "shape": [
                140
            ],
            "type": "continuous",
            "definition": "The minimum required ICU stay duration for each patient"
        },
        "HasTransfer": {
            "shape": [
                140
            ],
            "type": "binary",
            "definition": "Binary indicator whether each ICU stay results in a transfer out of the ICU"
        },
        "PlanningHorizon": {
            "shape": [],
            "type": "continuous",
            "definition": "The time horizon within which all transfer decisions must be made"
        }
    }
}